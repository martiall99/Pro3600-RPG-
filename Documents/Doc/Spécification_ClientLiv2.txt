// Cont_action :
typedef struct Cont_action Cont_action;
struct Cont_action
{
public:
	std::string titre;//nom de l'action
	std::string type;// attaque, magie, objet
	std::string descr;//description
public:
	void modif( std::string ti, std::string ty, std::string des );// change les 3 compos
	std::string toString() const ;// ( + est la concaténation ici) donne titre+sep+type+sep+descr avec sep un pont virgule '  ;  '
};
std::ostream& operator<<( std::ostream &flux, Cont_action const& cont );//utilise toString()




// Conteneur_carac
typedef struct Conteneur_carac Conteneur_carac;
struct Conteneur_carac
{
public:	
    int PV;
	int Mana;
	int PA;
	int DEF;// defence pour les ATTAQUES
	int RES;//resistance MAGIQUE
	int CRIT;// EN %*100
	int ESQ;// EN %*100
	int RENV;//renvoi des dommages
public:	
	std::string toString();// ( + est la concaténation ici) donne PV+sep+Mana+sep+PA+sep+DEF+sep+RES+sep+CRIT+sep+ESQ+sep+RENV avec sep un pont virgule '  ;  '
};
std::ostream& operator<<( std::ostream &flux, Conteneur_carac const& cont );




// Variables globales
// Transfert tran; bibliothèque bibl; Traduction trad; Client cli;
int ID_1;
int ID_1;


// Variable de :
//bibl :
Vector <int> tab_id;
Vector <std::string> tab_titre;
Vector <std::string> tab_descr;
int buffer_int;
std::string buffer_type;
std::string buffer_titre;
std::string buffer_descr;

//Transfert:
std::string IP_client;
std::string IP_serveur;
std::string port_client;
std::string port_serv;

//Trad
bool partie_debutee;

//client
int numero_coup;


//methode de:
//bibl:
private:
	void ajLigne();//créer la ligne dont les caractéristiques sont dans les buffers
	void modifLigne(int ligne);// remplace la ligne a modifier (dont les nouvelles caractéristiques sont dans les buffers)
	int rechLigne();// renvoie le numéro de la ligne dont l'ID est stockée dans buffer( ATTENTION il est en général différent de l'ID de l'action), renvoie -1 si l'id n'est pas stockée
	void interpreterLigne(std::string Ligne); // sépare chaque champ, remplit chaque buffer, appelle rechLigne(), si il y a une correspondance appelle modifLigne(), sinon ajLigne()
			//séparateur: '  ;  '  entre chaque "composante" (ID, titre, description) d'une action possible
public:
	Cont_action rechAction(int id);// rechLigne() puis renvoie un cont_action contenant le contenu de la ligne, si aucune correspondance renvoie des champs vides ""
	void mAJ(std::string MAJ);// sépare à ' / ' et appelle 	interpreterLigne() sur chaque, en remplacant au préalable le buffer_type avec le bon mot ( dans l'ordre : attaques, magie, objets, buffs) 
			//séparateur: '  /  '  entre chaque action possible   et ' . ' entre chaque type d'actions ( dans l'ordre : attaques, magie, objets) 

//transfert:
private:
	void recoitMessage();//transfere le texte du message à decodeTypeMessage()
	void decoServeur();//appelé lorsque le serveur se deco (pb connexion) , lance servPerdu()
	
	

public: //utilise par client
	void demandeCo(std::string IP);//se connecte à l'adresse ip fournie
	void demandeDeco();//se deconnecte de l'adresse Ip à laquelle est co, fait rien si l'on est pas co
	// utilisé par traduction:
	void envoieMess(std::string mess);//envoie la chaine à l'ip du serveur

//Traduction:
Private:// ces fonctions décodents les messages de type Tx, elles sont appelées par decode
	//pour le liv2 en  général il n'y a pas de choix pour la fonction qui sera appelée suivant le type de message 
	//en revanche il faut transformer la chaine de caractères en types de variables adéquats en enlevant CERTAINS séparateurs (pas forcément tous)

	// se REFERER au livrable 1 pour avoir l'ARCHITECTURE de chaque type de message, ATTENTION cette architecture dit que certaines parties du message sont des INT par exemple, 
	//mais le message est transmis sour forme d'un STING UNIQUE, au codeur de regarder comment découper son message et convertir les string en int par exemple pour retrouver les bons types


	void iT0(std::string mess); //pour liv2 ce sera forcement 0c()
			//pas de séparateur
	void iT1(std::string mess); // liv  2 : 1ds() ou 1fs()
			//pas de séparateur
	void iT2(std::string mess); // liv  2 : 2a() 
			//on ne touche PAS au séparateur
	void iT3(std::string mess); // liv  2 : 3a() pas de séparateur
	void iT4(std::string mess); // liv  2 : on appelle 4a() DEUX FOIS (une pour chaque perso en séparant suivant ' . ' )
			//séparateur: ' . ', on ne touche PAS aux ' ; '
	void iT6(std::string mess); // liv  2 : 6a() 
			//on ne touche PAS aux séparateurs
Public: 
	//utilisée par transfert
	void decodeTypeMessage(std::string mess);//envoie vers iTx avec x entre 0 et 6 inclus
	
	//utilisée par client
	void envAct( int num_coup, int act); //T3 envoie l'action choisie au serveur , avec le num_coup qui a été demandé par le serveur plus tot,
										//  en utilisant l'ID_1 et en convertissant le tout sous forme d'un unique string
	
	
//Client

public:
	void ChoixAction();// on lance un  promt avec une description demandant d'entrer l'action à utiliser,
					   // (il faut trouver une manière facile à traiter d'entrer ça et l'afficher dans la descri^ption des actions)
					   // PUIS reconnait ce qui est entré et utilise envAct() avec le bon num_coup et le bon id_action
	
	//utilisé par traduction (normalement ~=  dans l'ordre de réception)
	void Oc(int id_moi, int id_adv);// on sauvegarde les 2 id 
	void 1ds(); // serveur dit que partie débute, à priori on fait rien de spécial dans le cas du liv2 , ptetre juste afficher "le combat débute" ou un truc du genre ?
	void 6a(std::string maj); 									
			//séparateur: on n'y touche PAS c'est bibl qui s'occupe de tout
	void 4a(int id, std::string etat); // rempli un Conteneur_carac et l'affiche	en précédant de "moi" (= la personne qui joue ) ou "adversaire" suivant l'id
			//séparateur: '  ;  ' entre chaque carac
	void 2a(int num_coup, std::string actions_poss); //  affiche les possibilités dans "l'interface", puis   SI  num_coup= -1 s'arrète là , SINON demande à l'utilisateur d'entrer une action avec ChoixAction ()
			//séparateur: '  ;  '  entre chaque id d'action possible
	void 3a(int id, std::string act);// affiche "Je " OU "L'adversaire" + "utilise" + le nom de l'action en question, trouvé grâce à rechAction() dans le champ titre du conteneur renvoyé
	void 1fs(int id_gagnant);// serveur dit que partie est terminée , affiche qui a gagné 
	
	
	//utilise par transfert
	void servPerdu();// ecrit que le serveur s'est déconnecté puis arrète tout

//Fin
