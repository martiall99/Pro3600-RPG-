//----------------------------CLASSES PRELIMINAIRES (utilisées par personnage)------------------

typedef struct Conteneur_carac Conteneur_carac;
struct Conteneur_carac
{
public:	
    int PV;
	int Mana;
	int PA;
	int DEF;// defence pour les ATTAQUES
	int RES;//resistance MAGIQUE
	int CRIT;// EN %*100
	int ESQ;// EN %*100
	int RENV;//renvoi des dommages
public:	
	std::string toString();// PAS sur qu'on ait le droit comme c'est une struct, mais je crois que ça marchera et sinon au pire tout mettre dans le operator<<
						   // ( + est la concaténation ici) donne PV+sep+Mana+sep+PA+sep+DEF+sep+RES+sep+CRIT+sep+ESQ+sep+RENV avec sep un pont virgule '  ;  '
};
std::ostream& operator<<( std::ostream &flux, Conteneur_carac const& cont );


class Action
{
	int a_id;
	std::string a_nom;
	std::string a_descr;
	std::string toString();// ( + est la concaténation ici) donne a_id+sep+sep+a_nom+sep+a_descr avec sep un pont virgule '  ;  '
	
public:
	Action();//constructeur "vide" créer juste les structures en les laissant vides
};
std::ostream& operator<<( std::ostream &flux, Action const& act );

class Trad_action
{
	
public:// POUR LE LIV2 ne sert qu'a regrouper les textes (nom, description...) des Actions qu'il créé et initialise
	//utilisees par initTraducteurs() de Personnage

	Trad_action();//constructeur qui défini (code les fonctions supplémentaire par rapport à la classe Action) puis créé plusieurs objets qui HERITENT de la classe action
			// genre attaque simple, attaque puissante, bouclier, boule de feu , potion de vie, potion de mana ça devrait suffire pour liv2
	

	std::string listeID();//liste juste les ID séparéess par '   ;   ' , 
	std::string toString();//utilisé par l'opérateur <<,  lance le toString() de chaque action et les liste, séparéess par un '.'

};
std::ostream& operator<<( std::ostream &flux, Trad_action const& trad);//utilise toString()


// --------------------------------"VRAIS" OBJETS ------------------------------





//Variables communes
// Transfert tr; Aiguillage aig; Maitre_jeu m_j; 
const int ID_1; 
const int ID_2;


//variables de :
//transfert:
std::string IP_1;
std::string IP_2;
std::string port_s;
std::string port_c;

//aiguillage:


//maitre_jeu
int num_coup_attendu;
int a_qui_jouer;
Personnage perso1; 
Personnage perso2; 
bool j_1_co;
bool j_2_co;
bool deb_tour;

//Personnage
private:
	Conteneur_carac caracs;
public://ouioui ce sont bien ses variables
	Trad_action magies;
	Trad_action attaques;
	Trad_action objets;
	Trad_action trad_buffs;
	Tab_buffs_effectifs buff_eff;


//----------------------------------------------------Méthodes de :


//initialisation de TOUTES les variables de tous les "objets" 
	void init();// c'est litteralement un copié collé de ce qui est en dessous :
/*
//Variables communes
ID_1=1; 
ID_2=2;

//transfert:
IP_1="";
IP_2="";
port_s="";// A CHANGER !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
port_c="";// A CHANGER !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

//aiguillage:


//maitre_jeu
num_coup_attendu=0;
a_qui_jouer=ID_1;
perso1(); //on rappelle les constructeurs au cas ou
perso2(); 
j_1_co=false;
j_2_co=false;
deb_tour=true;

//Personnage
caracs();
magies();
attaques();
objets();
trad_buffs();
buff_eff();


*/

	
//transfert:
private:
	void tCoClient();//garde l'IP (dans le bon slot ) et appelle direct  co() de maitre_jeu
	void tDecoClient();//appelle directement deco() de maitre_jeu
	void recoitMess(); 
	
public:
	// utilisée par aiguillage
	void envoiMess(std::string mess, int id_dest );
	//util au tout debut/fin
	void ouvrirConnex();
	void fermerConnex();
	
	
	
	
//aiguillage
private:
	//remarque ici pas d'iT1, le jeu debute dès que les 2 cleints ont dit quels personnages ils prenaient
	void iT3a(std::string mess);
	
public://util par transfert
	void decodeMess(string mess);// appelle les iTx ici uniquement iT3 donc en soit n'est pas nécessaire mais le sera pour livrable 3
	//util par m_j
			//celles qui envoient au 2
	void envEtats(std::string e);//T4
	void envDeb();//T1d
	void envFin(int gagnant);//T1f
	void envBibli(std::string bib);//T6
	void retransmet3(std::string a);
	void envID();//T0c: envoie les 2 ID à la suite 2 fois (une pour chaque destinataire) avec à l'ID du destinataire en PREMIER
			//celle qui n'envoie qu'à la bonne ID
	void envActs(std::string a, int ID_dest); //T2a  

	
	
	
//maitre_jeu
private:

	void initBibli();// on récupère les 4  attaques.toString(), magies.toString(), objets.toString() , trad_buffs.toString()  puis appelle envBibli()
	void debutJeu();// 1) initTraducteurs() des 2 persos 2) initBibli() , 3)etatsPersos() des 2 puis envEtats()  4)  envDeb() 5) debTour()
	int aGagne();//renvoie l'id du joueur qui a gagné (joueur adverse a PV<=0 ) ou  -1 si 
	void debTour();//applique le buffsDebuffs() et  regenPA  de chaque personnage, puis lance tour()

	
public:
	//util par aiguillage
	void recoitT3A(int num_coup, int id_j, std::string ac);//verifie id et num_coup, puis incremente  num_coup_attendu, puis retransmet3() puis Act() de personnage
	
	//util par transfert 
	void co(int id);//SI j_1_co==false le met a true        OU           SI j_2_co==false le met a vrai ET et lance envID() ET lance debutJeu()
	void deco(int id);
	
	//util par perso
	void changeAQuiJouer();// change id puis SI deb_tour==true met deb_tourà false et lance debTour() SINON met deb_tour à true et lance tour();
	void tour();// 0) regarde a_qui_jouer ( PUIS vérifie aGagne() , interromp tout et envFin() si c'est le cas ) puis  1)recupere etatsPersos()  2) envEtats 3)recupere listeActionsPos() du bon joueur  puis 4) envActs() au bon joueur
	
	
	
//personnage
public:
	void buffsDebuffs();// sauvegarde buff_eff.parcourBuff dans une var v puis TANT QUE ( v != -1 ) on effectue Act(v) (RAPPEL un buff est une Action "comme les autres")
	void regenPa();
	void Act(string a);// SI l'action ac ="00" => changeAQuiJouer() de maitre_jeu  , SINON utilise rechID() des 4 traducteurs puis effectue la bonne action puis lance tour() 
	void initTraducteurs();//c'est celle qui ajoute toutes les actions possibles pour un personnage, elle n'est PAS appelée par le constructeur 
	std::string listeActionsPos(int id_j);//on recupere les 3 attaques.listeID(), magies.listeID(), objets.listeID()  et on les concatène avec en séparateur ' /  '
	std::string etatsPerso();//recupere le caracs.toString() et sépare par ' . '