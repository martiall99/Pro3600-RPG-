//----------------------------CLASSES PRELIMINAIRES (utilisées par personnage)------------------

typedef struct Conteneur_carac Conteneur_carac;
struct Conteneur_carac
{
public:	
    int PV;
	int Mana;
	int PA;
	int DEF;// defence pour les ATTAQUES
	int RES;//resistance MAGIQUE
	int CRIT;// EN %*100
	int ESQ;// EN %*100
	int RENV;//renvoi des dommages
public:	
	std::string toString();// PAS sur qu'on ait le droit comme c'est une struct, mais je crois que si au pire tout mettre dans le operator<<
};
std::operator<<();// REMPLIR LA PARENTHESE ICI avec un Conteneur_carac  et ce qu'il faut


class Action
{
	int a_id;
	std::string a_nom;
	std::string a_descr;
	std::string a_type;//attaque, magie, potion, buff....
	std::string toString();
	
public:
	Action();//constructeur "vide" créer juste les structures en les laissant vides
};
std::operator<<();// REMPLIR LA PARENTHESE ICI avec un Action  et ce qu'il faut

class Trad_action
{
	vector <int> ID;
	vector <Action> act;// ATTENTION il est possible que ceci ne marche pas (troncature des classes qui heritent ne gardant que les arguments et les methodes de la classe mère (donc en gros rien de ce qui nous interesse) ) et qu'il faille faire avec un pointeur: ' vector<Action*> act; ' et donc fonctionnement différent
	
public:
	//utilisees par initTraducteurs() de Personnage

	Trad_action();//constructeur "vide" créer juste les structures en les laissant vides
	
	void ajAction(int id_a, Action ac);//même chose peut etre Action* act
	void enlAction(int id_a);
	std::string toString();//utilisé par l'opérateur <<
	bool verifPasDoublons();
	
	Action rechID(int id_r);// c'est la "principale" de cette classe et MEME CHOSE peut être renvoyer un pointeur à la place de l'objet...
};
std::operator<<();// REMPLIR LA PARENTHESE ICI avec un Trad_action  et ce qu'il faut


class Tab_buffs_effectifs
{
	vector <int> ID;
	vector <int> nb_tours_restants;
	int buffer_boucle;//init a 0 dans le constructeur
public:		
	Tab_buffs_effectifs();//constructeur "vide" créer juste les structures en les laissant vides
	
	void ajBuff(int ID_b, int nb_tours);
	void enlBuff(int ID_b);
	void decrementeBuff(int ID_b);//decremente de 1 le compteur nb_tours_restants  ATTNETION n'appelle PAS enlbuff si arrive à 0 (sinon problème de parcours du tableau)
	void enlTousBuffsFinis(); parcours le tableau et appelle enlBuff si nb_tours_restants arrive a 0 ATTENTION 
	int parcourBuff();// lit et renvoie l' ID de l'element en position buffer_boucle, lorsque l'on arrive à la fin du tableau, on appelle enlTousBuffsFinis() , on remet buffer à 0 et on renvoie -1 
	std::string toString();
};
std::operator<<();// REMPLIR LA PARENTHESE ICI avec un Tab_buffs_effectifs  et ce qu'il faut


// --------------------------------"VRAIS" OBJETS ------------------------------





//Variables communes
// Transfert tr; Aiguillage aig; Maitre_jeu m_j; 
const int ID_1; 
const int ID_2;


//variables de :
//transfert:
std::string IP_1;
std::string IP_2;
std::string port_s;
std::string port_c;

//aiguillage:


//maitre_jeu
int num_coup_attendu;
int a_qui_jouer;
Personnage perso1; 
Personnage perso2; 

//Personnage
private:
	Conteneur_carac caracs;
public://ouioui ce sont bien ses variables
	Trad_action magies;
	Trad_action attaques;
	Trad_action objets;
	Trad_action trad_buffs;
	Tab_buffs_effectifs buff_eff;


//Méthodes de :

//transfert:
private:
	void tCoClient();//garde l'IP et appelle direct maitre_jeu
	void tDecoClient();//appelle directement maitre_jeu
	void recoitMess();
	
public:
	// utilisée par aiguillage
	void envoiMess(std::string mess );
	//util au tout debut/fin
	void ouvrirConnex();
	void fermerConnex();
	
	
	
	
//aiguillage
private:
	//remarque ici pas d'iT1, le jeu debute dès que les 2 cleints ont dit quels personnages ils prenaient
	void iT3a(std::string mess);
	
public://util par transfert
	void decodeMess(string mess);// appelle les iTx 
	//util par m_j
	void envActs(std::string a); //T2a
	void envEtats(std::string e);//T4
	void envDeb();//T1d
	void envFin(int gagnant);//T1f
	void envBibli(std::string bib);//T6
	
	
	
//maitre_jeu
private:

	void initBibli();
	void retransmet3(std::string mess3);
	void debutJeu();// 1) initTraducteurs() des 2 persos 2) recupere listeActionsPos() pour la biliotheque et envBilbi() , 3)etatsPersos() des 2 puis envEtats()  4)  envDeb() 5) debTour()
	int aGagne();//renvoie l'id du joueur qui a gagné (joueur adverse a PV<=0 ) ou  -1 si 
	void debTour();//applique le buffsDebuffs() et  regenPA  de chaque personnage, puis lance tour()

	
public:
	//util par aiguillage
	void recoitT3A(int num_coup, int id_j, std::string ac);//verifie id et num_coup, puis Act() de personnage
	
	//util par transfert 
	void co(int id);
	void deco(int id);
	
	//util par perso
	void changeAQuiJouer();// change id puis lance debTour()
	void tour();// 0) regarde a_qui_jouer ( PUIS vérifie aGagne() , interromp tout et envFin() si c'est le cas ) puis  1)recupere etatsPersos()  2) envEtats 3)recupere listeActionsPos() du bon joueur  puis 4) envActs() au bon joueur
	
	
	
//personnage
public:
	void buffsDebuffs();// sauvegarde buff_eff.parcourBuff dans une var v puis TANT QUE ( v != -1 ) on Act(v) (RAPPEL un buff est une Action "comme les autres")
	void regenPa();
	void Act(string a);// SI l'action ac ="00" => changeAQuiJouer() de maitre_jeu  , SINON cherche dans les traducteurs la bonne action et l'effectue puis lance tour() 
	void initTraducteurs();//c'est celle qui ajoute toutes les actions possibles pour un personnage, elle n'est PAS appelée par le constructeur 
	std::string listeActionsPos(int id_j);
	std::string etatsPerso();//recupere le caracs.toString()